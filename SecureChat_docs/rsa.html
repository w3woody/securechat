<html>
	<head>
		<title>RSA</title>
		<link type="text/css" rel="stylesheet" href="SecureChat.css"> 
	</head>
	<body>
		<h1>RSA Implementation</h1>
		<p>This page describes the RSA implementation used for securing communications
			end-to-end using the SecureChat system. This document will refer to the source
			kit for the iOS client and server.</p>
		<h2>Rational</h2>
		<p>The current implementation for RSA on iOS is contained in the iOS API call
			<i>SecKeyGeneratePair</i>, which can be used to generate a secure RSA public
			and private key to encode messages. All of this is documented here:</p>
		<p><a href="https://developer.apple.com/library/ios/documentation/Security/Reference/certifkeytrustservices/index.html">Certificate, Key and Trust Services Reference</a></p>
		<p>On iOS, the private key is automatically stored in the device keystore, and there
			is (as of this writing) no method that I am aware of to obtain the private key
			generated by iOS. Further, the implementation is completely opaque to the
			developer; we have no idea how strong (or weak) the resulting key is.</p>
		<p>Now for most commercial applications, this is far more than adequate. For now
			we can trust that Apple has the best interest of the consumer of their products,
			and so we can trust that Apple's RSA implementation is fast, efficient, and
			secure. The architecture of the iOS RSA implementation (denying a developer
			access to the private key) is also ideal for most typical applications, especially
			in light of developers who may not fully understand the implications of a
			public/private key architecture and who may do something stupid--like transmitting
			the private key in the clear.</p>
		<p>However, we are assuming a few things:</p>
		<p>First, we are assuming that the Apple v FBI case (or some future case) will force
			Apple to deliberately weaken their keystore architecture to allow government
			agencies (and, by extension, to poorly behaving public employees, and eventually
			to hackers) access to the contents of the keystore. Second, we are assuming that
			a nation-state or agency will require Apple to weaken their RSA encryption system,
			for example, by limiting prime number selection, in order to generate what is
			announced as a strong key but with a weakened prime selection algorithm.</p>
		<p>Thus, our own RSA implementation.</p>
		<p>(<b>Note:</b> If you intend to implement a commercial application using RSA 
			encryption, <i>I cannot stress more strongly</i> that you should be using the
			Apple API, or a third party API which provides cryptographic services, such as
			the <a href="https://tls.mbed.org">ARMmbed</a> cryptographic library. I would
			argue that this implementation of RSA is as secure as these other systems, but
			(deliberately by design) this implementation is not standards compatible.</p>
		<p>Further, I am <i>assuming</i> in the future that somehow the existing RSA 
			infrastructure has been compromised in order to demonstrate how all of these 
			tools can be built by a third party from the ground up. I am not suggesting
			that they have been compromised; in fact, many officials and ex-officials from
			various agencies (such as the National Security Agency) has repeatedly argued that 
			we need 
			<a href="http://money.cnn.com/2016/01/13/technology/nsa-michael-hayden-encryption/index.html">stronger encryption,</a> 
			not weaker encryption.</p>
		<p>Given how much of our economy now relies on strong encryption (such as banking),
			it would be a disaster if the government <i>actually weakened encryption</i> just
			for "law enforcement" reasons.)</p>
		<h2>Implementation</h2>
		<h3>Big Integers</h3>
		<p><a href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">RSA encryption</a>
			works by creating a public key and a private key, relying on the difficulty of
			finding the prime factors of a very large integer. This means we need to start with
			a library that can manipulate very large integers.</p>
		<p>On Java we use the built-in 
			<a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html">BigInteger</a>
			class. On iOS we roll our own.</p>
		<p>The C++ class SCBigInteger (in RSA/BigInt) implements big integer math, by
			representing integers as an array of 32-bit integers. This assumes the availability
			of 64-bit integers for intermediate results; as this code targets modern iOS
			hardware, that should be true on all supported devices.</p>
		<p>Most of the implementation is not very noteworthy; algorithms for big integer math
			can be found in Chapter 14 of 
			<a href="http://cacr.uwaterloo.ca/hac/">Handbook of Applied Cryptography</a>.</p>
		<p>There are a few noteworthy items in our implementation.</p>
		<p>First, the method <i>IsProbablePrime</i> uses the Rabin-Miller algorithm, using
			the certainty parameter similar to that used in the Java BigInteger implementation,
			described in Chapter 11, section 5 of 
			<a href="https://www.schneier.com/books/applied_cryptography/">Applied Cryptography</a>. 
			The correctness of this algorithm can seriously impact both prime selection and
			the validity of primes selected for our RSA system.</p>
		<p>Second, because we use integer modulus repeatedly in our RSA system, and by 
			construction the value of N in our RSA key is guaranteed to be an odd value, we
			implement Montgomery exponentiation for calculating <i>a<sup>b</sup> mod c</i> in the
			class SCMontMath, by using the algorithms described in Chapter 14 of <a href="http://cacr.uwaterloo.ca/hac/">Handbook of Applied Cryptography</a>. We don't attempt to optimize
			for even modulus values, however.</p>
		<p>Third, we do rely on the cryptographic random number generator built into the iOS
			operating system. If you believe that has been compromised you are welcome to replace
			the random number generator. However, remember that creating your own 
			cryptographically secure random number generator is <i>hard,</i> and a whole
			topic of its own. Unless you know what you are doing, you may consider not wanting
			to roll your own random number generator.</p>
			
		<h3>RSA Key Generation</h3>
		<p>The RSA Key generation algorithm is implemented in the function 
			<i>SCRSAKeyGeneratePair</i>, in the file SCRSAEncryption.cpp. This is the heart of
			the RSA generation code, using the SCBigInteger class for large integer
			processing. The steps for generating an RSA key is outlined in 
			<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">the Wikipedia article on RSA encryption,</a>
			and basically are:</p>
		<ul><li>Given S the number of desired bits in the RSA key,</li></ul>
		<ol><li>Generate two primes P and Q that are S/2 bits long.</li>
			<li>Calculate N = P * Q.</li>
			<li>Calculate phiN = (P - 1) * (Q - 1)</li>
			<li>Find E such that GCD(E,phiN) == 1 and E &lt; phiN. The pair (E,N) is our 
			public key.</li>
			<li>Find D = E<sup>-1</sup> mod phiN. The pair (D,N) is our private key.</li></ol>
		<p>Our implementation then validates the key pair by picking 5 random values and 
			verifying that for all random values R that is S-2 bits in size,
			<i>R = (R<sup>D</sup> mod N) <sup>E</sup> mod N.</i> If this relationship (which
			basically encrypts and decrypts R to verify we get back the same value) does not
			hold, something went haywire with our prime selection P and Q, and we start the
			process over again.</p>
		<p>Once generated, we store both our public and private keys in the object
			SCRSAKey, which contains code for serializing and deserializing RSA keys, and
			for quickly calculating A<sup>E</sup> mod N.</p>
		
		<h3>RSA Block Encoding</h3>
		<p>Each RSA key of size S bits can only encode up to S-2 bits of data. That's because
			the two primes we've selected are S/2 bits long, meaning their values are between 2<sup>S/2-1</sup> and 2<sup>S/2</sup>-1. This implies that our modulus N = P * Q is
			between 2<sup>S-2</sup> and 2<sup>S</sup>; this implies the maximum value we can
			run through the RSA algorithm is S-2 bits in length.</p>
		<p>For S = 1024 bits, that means our maximum message size is 1022 bits, or about 
			127 bytes. Larger messages must be broken into chunks to be encoded.</p>
		<p>Now of course there are problems with simply breaking our message into chunks of
			S-2 bits in length and applying the RSA math operation, so we rely on the principles
			behind <a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding">
				Optimal Asymmetric Encryption Padding</a> to encrypt our packets.
			Our implementation varies from the implementation described in the Wikipedia article
			in the following ways:</p>
		<ul><li>The number of bits k<sub>1</sub> is set to 2 bits; that is, if we use a bit
			size of S, we pad the top 2 bits to 0 in order to make our value fit in S-2 bits.
			By setting k<sub>1</sub> to the smallest value possible we maximize the entropy
			of each block of data; every zero beyond the bare minimum necessary reduces the
			entropy of the message and thus the effectiveness of encryption.</li>
			<li>We set k<sub>0</sub> to S/8-10 bits; this is the size of the cryptographic random
			value that is added to each packet of our message to increase the overall entropy
			of the messages being sent. If the packet is larger than the 128 bits returned by
			SHA-256 (which is our cryptographic has to calculate G and H), we repeat the
			bit pattern.</li>
			<li>To each message we add a 1 byte (8 bit) CRC-8 checksum to verify the encoding
			and decoding process worked; the weak checksum is a deliberate choice to help us
			determine of decoding worked, but provides a 1 in 256 chance of a false positive if
			the wrong key was used.</li></ul>
		<p>Our implementation of this padding scheme is contained in the class SCRSAPadding.</p>
		<h3>Other classes of note</h3>
		<p>On iOS other classes and files have been implemented which are noteworthy.</p>
		<p><b>SCUUIDGenerator</b> implements a UUID generator which generates version 4 UUID
			keys from cryptographically randomly selected values. 
			<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID keys</a>
			are used to identify devices to the back-end, and this assures that we do not 
			send device-identifying information to the back-end as part of a version of UUID 
			that uses identifying information to generate unique keys.</p>
		<p><b>SCBlowfish</b> implements the 
			<a href="https://en.wikipedia.org/wiki/Blowfish_(cipher)">Blowfish algorithm.</a></p>
		<p><b>SCChecksum</b> implements the CRC-8 checksum.</p>
		<p><b>SCSecureHash</b> and <b>SCSHA256Context</b> implements the <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">SHA-256 hash function.</a></p>
		
		
		<h2>References</h2>
		<p><a href="https://www.schneier.com/books/applied_cryptography/">Applied Cryptography</a></p>
		<p><a href="http://cacr.uwaterloo.ca/hac/">Handbook of Applied Cryptography</a></p>
		<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA Cryptography</a></p>
		<p><a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding">
				Optimal Asymmetric Encryption Padding</a></p>
		<p><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">Universally unique identifier</a></p>
		<p><a href="https://en.wikipedia.org/wiki/Blowfish_(cipher)">Blowfish algorithm.</a></p>
		<p><a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">FIPS PUB 180-4: Secure Hash Standard.</a></p>
		
		
	</body>
</html>
